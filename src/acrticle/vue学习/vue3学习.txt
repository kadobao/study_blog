vue学习
23 September 2024
 created group «vue学习» with members 
本机 joined group by link from Group
23:47

npm list -g typescript


tsc --version
23:52

24 September 2024
00:02

根据您提供的文件结构截图，以下是每个文件或文件夹的作用说明：

### 1. .vscode/
这是 Visual Studio Code 的配置文件夹，通常包含工作区的设置文件（如 `settings.json`），用于保存编辑器的特定配置。比如可以在这里配置 TypeScript、ESLint 或者格式化工具的行为。

### 2. `public/`
这个文件夹通常用于存放公开的静态资源，比如图像、HTML 文件、图标等。在前端项目中，`public` 目录中的文件会直接被打包到生产环境中，且这些文件的路径不会被 Webpack、Vite 或其他打包工具处理。

### 3. src/
src 是项目的源代码文件夹。所有的应用逻辑、组件、样式等都通常放在这个文件夹中。代码会被打包工具处理后生成用于生产的代码。

### 4. .gitignore
.gitignore 文件告诉 Git 哪些文件或目录不需要被版本控制。例如，依赖包的文件夹（如 node_modules/`）通常会被添加到 .gitignore` 中，以避免它们上传到 Git 仓库。

### 5. env.d.ts
这是一个 TypeScript 声明文件，用于声明项目中的环境变量或自定义模块的类型定义。通常，`.d.ts` 文件用于为 JavaScript 库或自定义代码提供类型提示和类型检查。

### 6. index.html
这个文件是项目的主 HTML 文件。前端应用程序在浏览器中启动时，会首先加载这个文件。在项目构建时，打包工具会注入应用程序的 JavaScript 代码，并将其链接到这个 HTML 文件中。

### 7. package.json
这是一个 Node.js 项目的配置文件，列出了项目的依赖项、脚本命令、项目信息（如名称、版本）等。`package.json` 是 npm 和 Yarn 等包管理工具使用的核心文件。通过它，可以快速安装和管理项目依赖。

### 8. README.md
这个文件通常用于存放项目的介绍和使用说明。它是用 Markdown 语法编写的，通常包括如何启动项目、开发者指南、项目结构说明等内容。

### 9. tsconfig.app.json
这是 TypeScript 的配置文件之一。它包含了 TypeScript 编译器的配置选项，专门用于应用程序的编译。`tsconfig` 文件告诉 TypeScript 如何编译项目中的 TypeScript 代码。

### 10. tsconfig.json
这是 TypeScript 项目的全局配置文件，定义了如何编译整个项目中的 TypeScript 代码。它指定了项目的编译选项、类型检查规则、要包含的文件和排除的文件等。

### 11. tsconfig.node.json
这是另一个 TypeScript 配置文件，通常用于处理项目中的 Node.js 环境相关的 TypeScript 配置。例如，如果项目中使用了 Node.js 的特定模块或 API，这个文件会为其提供合适的编译配置。

### 12. vite.config.ts
这是 Vite 的配置文件，并且使用 TypeScript 编写。Vite 是一个现代的前端构建工具，专注于提供快速的开发体验。这个文件配置了项目的构建、插件、开发服务器设置等内容。

---

总体来说，这个文件结构展示了一个使用 TypeScript 和 Vite 的前端项目。TypeScript 配置文件（如 tsconfig.json`）用于类型检查和代码编译，而 `vite.config.ts 文件配置了打包和开发工具。
00:02

00:14
package.json是项目的依赖清单，配置文件
00:19
package-lock.json 是 npm（Node Package Manager）在安装依赖包时自动生成的一个文件。它的主要作用是锁定项目依赖包的版本，
00:28
main.ts（或 main.js）是 Vue 应用的入口文件。它负责初始化 Vue 应用，并将其挂载到 DOM 中的某个元素上。
00:28
App.vue 是 Vue 应用的根组件。
00:31
创建 Vue 实例：

使用 createApp 方法（在 Vue 3 中）或 new Vue 方法（在 Vue 2 中）创建 Vue 实例，并传入根组件 App.vue。
00:31
创建一个房子，然后装饰它，组件就是用来修饰的
00:34
vue里面就是模板，脚本，样式
00:52

组件就是模块，装饰品，一个个ui模块
00:52
name 属性：用于指定组件的名称，方便开发工具显示和组件递归调用。

components 属性：用于注册子组件，使得组件可以嵌套使用，提高代码的复用性和可维护性。
00:55
name的值就是文件的文件名
00:58
在 Vue.js 中，子组件需要在使用它的父组件中注册，然后才能在父组件的模板中使用。
00:58
是的，在 Vue.js 中，子组件需要在使用它的父组件中注册，然后才能在父组件的模板中使用。这个过程通常包括以下几个步骤：

### 1. 引入子组件

首先，你需要在父组件的脚本部分引入子组件。

### 2. 注册子组件

然后，在父组件的 components 属性中注册子组件。

### 3. 在模板中使用子组件

最后，在父组件的模板中使用子组件。

### 示例

假设你有两个组件：ParentComponent.vue 和 ChildComponent.vue。你需要在 ParentComponent.vue 中注册并使用 ChildComponent.vue。

#### ChildComponent.vue

<template>
  <div class="child-component">
    <p>{{ message }}</p>
  </div>
</template>

<script>
export default {
  name: 'ChildComponent',
  data() {
    return {
      message: 'Hello from ChildComponent!',
    };
  },
};
</script>

#### ParentComponent.vue

<template>
  <div class="parent-component">
    <h1>Parent Component</h1>
    <ChildComponent />
  </div>
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
  name: 'ParentComponent',
  components: {
    ChildComponent,
  },
};
</script>

### 详细步骤

#### 1. 引入子组件

在 ParentComponent.vue 的脚本部分，使用 import 语句引入 ChildComponent.vue：

import ChildComponent from './ChildComponent.vue';

#### 2. 注册子组件

在 ParentComponent.vue 的配置对象中，使用 components 属性注册 ChildComponent：

export default {
  name: 'ParentComponent',
  components: {
    ChildComponent,
  },
};

#### 3. 在模板中使用子组件

在 ParentComponent.vue 的模板部分，使用 <ChildComponent /> 标签来使用子组件：

<template>
  <div class="parent-component">
    <h1>Parent Component</h1>
    <ChildComponent />
  </div>
</template>

### 总结

在 Vue.js 中，子组件需要在使用它的父组件中注册，然后才能在父组件的模板中使用。这个过程包括引入子组件、注册子组件和在模板中使用子组件三个步骤。通过这种方式，你可以将复杂的 UI 拆分成多个小的、独立的组件，提高代码的可维护性、复用性和开发效率。
01:01
在 Vue.js 中，export default { name: 'App' } 是一种常见的语法，用于导出一个 Vue 组件。这个语法主要包含以下几个部分：

### 1. export default

export default 是 ES6 模块系统中的一个关键字，用于导出一个模块的默认输出。在 Vue 组件中，export default 用于导出组件的配置对象。

### 2. { name: 'App' }

{ name: 'App' } 是一个对象字面量，表示 Vue 组件的配置对象。这个对象可以包含多个属性，用于定义组件的行为和结构。

#### 主要属性

- **name**:
- name 属性用于指定组件的名称。这个名称在开发工具（如 Vue DevTools）中显示，并且在组件递归调用时也会用到。
- 示例：name: 'App' 表示这个组件的名称为 App。

- **components**:
- 用于注册子组件。你可以在这里引入其他组件，并在模板中使用它们。
- 示例：

    components: {
      Header,
      Footer,
    }
    

- **`data`**:
- 用于定义组件的响应式数据。data 必须是一个函数，返回一个对象。
- 示例：

    data() {
      return {
        message: 'Hello, Vue!',
      };
    }
    

- **`methods**:
- 用于定义组件的方法。这些方法可以在模板中调用，也可以在组件的其他部分使用。
- 示例：
``javascript
methods: {
greet() {
alert(this.message);
},
}


- **`computed`**:
  - 用于定义计算属性。计算属性是基于依赖进行缓存的属性，只有在它的依赖发生变化时才会重新计算。
  - 示例：
    

javascript
computed: {
reversedMessage() {
return this.message.split('').reverse().join('');
`watch`}


- **`watch`**:
  - 用于监听数据的变化。当监听的数据发生变化时，会触发相应的回调函数。
  - 示例：
    

javascript
watch: {
message(newVal, oldVal) {
console.log(Message changed from ${oldVal} to ${newVal});
`mounted`

- **`mounted`**:
  - 生命周期钩子之一，在组件挂载到 DOM 后调用。
  - 示例：
    

javascript
mounted() {
console.log('Component mounted.');
}


### 示例

vue
<template>
<div id="app">
<Header />
<router-view />
<Footer />
</div>
</template>

<script>
import Header from './components/Header.vue';
import Footer from './components/Footer.vue';

export default {
name: 'App',
components: {
Header,
Footer,
},
data() {
return {
message: 'Hello, Vue!',
};
},
methods: {
greet() {
alert(this.message);
},
},
computed: {
reversedMessage() {
return this.message.split('').reverse().join('');
},
},
watch: {
message(newVal, oldVal) {
console.log(Message changed from ${oldVal} to ${newVal});
},
},
mounted() {
console.log('Component mounted.');
},
};
</script>

<style>
#app {
font-family: Avenir, Helvetica, Arial, sans-serif;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
text-align: center;
color: #2c3e50;
margin-top: 60px;
}
</style>
`

### 总结

`export default { name: 'App' }` 是 Vue 组件的导出语法，用于定义组件的配置对象。这个对象可以包含多个属性，用于定义组件的名称、数据、方法、计算属性、监听器、生命周期钩子等。通过这种方式，Vue 可以正确地解析和渲染组件。
01:02
main.ts（或 main.js）是 Vue 应用的入口文件。它负责初始化 Vue 应用，并将其挂载到 DOM 中的某个元素上。
09:20

在Vue 3中，setup 是一个新的组件选项，用于替代 Vue 2 中的 data、methods、computed 等选项。setup 函数是 Composition API 的核心部分，它允许你以一种更灵活、更直观的方式组织和复用组件逻辑。

### setup 函数的基本结构

setup 函数在组件创建之前执行，并且它的返回值会被暴露给组件的模板和其他选项（如 render 函数）。setup 函数接收两个参数：

1. **props**: 组件的 props，是一个响应式的对象。
2. **context**: 包含了一些上下文属性，如 attrs、slots、emit 等。

export default {
  props: {
    message: String
  },
  setup(props, context) {
    // 在这里定义响应式数据、计算属性、方法等

    // 返回一个对象，对象中的属性会被暴露给模板
    return {
      // 返回的属性
    }
  }
}

### 使用 `setup 定义响应式数据

在 setup 中，你可以使用 ref 或 reactive 来定义响应式数据。

- **ref**: 用于创建一个包装简单值（如数字、字符串）的响应式引用。
- **reactive**: 用于创建一个包含多个属性的响应式对象。

``javascript
import { ref, reactive } from 'vue'

export default {
setup() {
const count = ref(0) // 创建一个响应式的数字
const state = reactive({ // 创建一个响应式的对象
name: 'Vue 3',
version: '3.0'
})

// 返回的对象会被暴露给模板
return {
count,
state
}
}
}

### 使用 `setup` 定义方法

你可以在 `setup` 中定义方法，并将其返回，以便在模板中使用。

javascript
import { ref } from 'vue'

export default {
setup() {
const count = ref(0)

function increment() {
count.value++
}

return {
count,
increment
}
}
}

### 使用 `setup` 访问 `props` 和 `context`

`setup` 函数的第一个参数是 `props`，第二个参数是 `context`。`context` 包含了一些常用的属性，如 `attrs`、`slots`、`emit` 等。

javascript
export default {
props: {
message: String
},
setup(props, { attrs, slots, emit }) {
console.log(props.message) // 访问 props
console.log(attrs) // 访问 attrs
console.log(slots) // 访问 slots

function sendEvent() {
emit('custom-event', 'some data') // 触发事件
}

return {
sendEvent
}
}
}

### 生命周期钩子

在 `setup` 中，你可以使用 Vue 3 提供的生命周期钩子函数，如 `onMounted`、`onUpdated`、`onUnmounted` 等。

javascript
import { ref, onMounted } from 'vue'

export default {
setup() {
const count = ref(0)

onMounted(() => {
console.log('Component mounted!')
})

return {
count
}
}
}
`

### 总结

`setup` 是 Vue 3 中 Composition API 的核心，它提供了一种更灵活、更直观的方式来组织和复用组件逻辑。通过 `setup`，你可以更清晰地定义响应式数据、方法、生命周期钩子等，并且可以更好地与 TypeScript 结合使用。
10:29

在 Vue 3 中，setup 函数可以返回一个渲染函数（render function）。这种方式允许你直接在 setup 函数中定义组件的渲染逻辑，而不需要使用模板（template）。
10:32
index.html是入口文件，让然后main.ts是创建一个应用和vue根组件，并绑定在index里面的一个元素里面，其他组件是依赖于根组件，需要在根组件里面注册，而要能注册，就需要导出，所以有export default导出
10:42
语法糖就是简单的写法
10:43
箭头函数：在 JavaScript 中，箭头函数 () => {} 是传统函数表达式 function() {} 的语法糖。箭头函数提供了更简洁的语法，并且在处理 this 上下文时更加直观。
14:03

在Vue模板中，使用双大括号 {{ }} 来插入或绑定 JavaScript 表达式。双大括号中的内容会被 Vue 的模板引擎解释为动态数据，并将结果插入到 HTML 中。

在你提供的代码中：

<h2>一辆{{car.brand}}车，价值{{car.price}}万</h2>


- {{car.brand}} 表示插入 car 对象中的 brand 属性的值。
- {{car.price}} 表示插入 car 对象中的 price 属性的值。

这些表达式将会被动态地解析，并显示为实际数据（例如：`一辆奔驰车，价值100万`）。大括号的作用就是从 Vue 的数据对象中获取相应的数据并显示在页面上。
14:15

子组件是一个个模块，不在根组件哪里注册和使用是没有任何作用的，要这样使用
14:28

基本数据类型变成响应式的直接用ref包裹就行，对象变成响应式的要用reactive包裹
14:33
在Vue模板中，使用双大括号 {{ }} 来插入值
14:41
<li v-for="g in games" :key="g.id"></li>
v-for 用于遍历数组或对象，生成多个相同的元素。

:key 用于为每个生成的元素提供一个唯一的标识符
14:55

14:58

15:05
为什么需要两者？
Vue 项目需要两者的原因是：

模块化开发和优化：通过 assets/，你可以将静态资源模块化地与 Vue 组件结合，同时享受 Webpack 或 Vite 带来的优化（如文件压缩、缓存控制等）。
无需处理的全局资源：public/ 提供了一个存放全局静态资源的地方，这些资源不需要通过 JavaScript 引入，直接在 HTML 文件或其他全局文件中引用即可，且路径固定，适用于 favicon、robots.txt 等文件。
总结：
assets/ 文件夹主要用于需要模块化、动态导入、打包优化的资源。
public/ 文件夹则用于不需要打包工具处理、直接访问的资源。
15:15

Object.assign(car, {brand: '奥拓', price: 1}) 的作用是将 {brand: '奥拓', price: 1} 这个对象的属性合并到已经存在的 car 对象中。

具体作用：
Object.assign() 是 JavaScript 中的一个方法，用于将一个或多个源对象的可枚举属性复制到目标对象中。它的语法是：Object.assign(target, ...sources)。
car 是目标对象（即要被修改的对象），{brand: '奥拓', price: 1} 是源对象（要复制的属性的来源）
15:16

19:29


从响应式对象里面直接解析出来的东西不是响应式的，要使用toRefs解析，使用toRefs包裹响应式对象解析出来的东西就是响应式的了
20:13

v-bind 是 Vue.js 中的一个指令，用于动态绑定 HTML 元素的属性。它允许你将 Vue 实例中的数据动态地绑定到 HTML 元素的属性上。v-bind 可以简写为 :。

### 基本用法

v-bind 的基本语法如下：

<element v-bind:attribute="expression"></element>

其中：

- element：HTML 元素。
- attribute：HTML 元素的属性（如 class、style、src、href 等）。
- expression：Vue 实例中的数据或表达式。

### 简写形式

v-bind 可以简写为 :，所以上面的语法可以简写为：

<element :attribute="expression"></element>

### 示例

假设你有一个 Vue 实例，其中包含一个 url 数据属性：

new Vue({
  el: '#app',
  data: {
    url: 'https://www.example.com'
  }
});

你可以使用 `v-bind 将这个 url 绑定到一个 <a> 元素的 href 属性上：

``html
<div id="app">
<a v-bind:href="url">
20:16
v-model 是 Vue.js 中的一个指令，用于在表单输入元素和 Vue 实例的数据之间创建双向数据绑定。这意味着当用户在表单输入元素中输入内容时，Vue 实例中的数据会自动更新；
20:19
vue几乎不碰this，所以可以直接使用箭头函数
20:46


20:51
ref和reactive返回的都是响应式对象
20:52
ref的基本类型和对象里面键都是value，不过对象是键里面的值是一个对象
20:57

20:57

21:31


23:37


在 Vue 3 中，watch 函数的回调函数的参数是固定的，通常是 newValue 和 oldValue。这两个参数分别表示被观察数据的新值和旧值。
23:37

25 September 2024
13:00

env.d.ts 文件：
该文件是 TypeScript 的环境声明文件，用于定义一些全局的类型声明，或者为 .env 文件中的环境变量提供类型支持。

声明是告诉编译器这个变量是什么类型，这样编译器之后才好检查变量是否使用正确，比如x被声明为整数类型，但你试图将一个字符串赋值给它。编译器会检测到这个类型不匹配，并报错。
26 September 2024
02:17

唯一性：ref 属性在同一个组件中是唯一的，因此不会出现多个元素使用相同 ref 的情况。这避免了 document.getElementById() 中可能出现的 ID 冲突问题。


在 Vue 中，ref 属性确实是唯一的，但这里的“唯一”指的是在同一个组件内部，ref 属性的值必须是唯一的。而不是指只能有一个ref属性。
02:21
在 Vue 3 中，ref 函数用于创建一个响应式的引用。这个引用可以与模板中的 ref 属性关联起来，从而使得我们可以在 JavaScript 代码中通过这个引用来访问对应的 DOM 元素或组件实例。
02:24
在 Vue 组件中，你可以通过在 <style> 标签上添加 scoped 属性来启用局部样式。


组件一般都要加局部样式。这样别的组件就不会受这个影响。
02:29
在 Vue 中，ref 属性是组件级别的，这意味着每个组件的 ref 属性是独立的，不会与其他组件的 ref 属性冲突。即使两个组件中都使用了相同的 ref 属性名称（例如 title），它们也不会互相干扰，因为每个组件的 ref 属性只在该组件的作用域内有效。
02:38
在 Vue 中，如果你在模板中使用了 ref 属性来标记 DOM 元素或组件实例，那么你需要在脚本部分创建一个对应的 ref 函数来访问这些元素或实例。
02:43
在 Vue 中，虽然你可以通过 ref 属性获取子组件的实例，但这并不意味着你可以随意访问子组件的所有内容。为了确保组件的封装性和安全性，Vue 提供了一些机制来控制父组件对子组件内容的访问。

### 访问子组件的内容

要访问子组件的内容，子组件需要通过 defineExpose 显式地暴露其属性和方法。这样，父组件才能通过 ref 访问到这些暴露的内容。

### 示例

假设我们有两个组件：App.vue（父组件）和 Demo.vue（子组件）。我们希望在父组件中通过 ref 属性访问子组件的实例，并调用子组件的方法。

#### 父组件 (App.vue)

<template>
  <div class="root">
    <h1 ref="title">App组件</h1>
    <button @click="showTitle">Show Title</button>
    <Demo ref="demo" />
    <button @click="showDemo">Show Demo</button>
  </div>
</template>

<script setup lang="ts">
import Demo from './components/Demo.vue'
import { ref } from 'vue'

// 存储ref标记的内容
const title = ref()
const demo = ref()

function showTitle() {
    console.log(title.value)
}

function showDemo() {
  console.log(demo.value)
  demo.value.someMethod() // 调用子组件的方法
  console.log(demo.value.someData) // 访问子组件的数据
}
</script>

<style scoped lang="scss">
.root {
  background-color: orange;
  padding: 20px;
}
</style>

#### 子组件 (Demo.vue)

<template>
    <div class="demo">
        <h1 ref="title">Demo组件</h1>
        <button @click="showTitle">Show Title</button>
    </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

// 创建一个title用于存储ref标记的内容
const title = ref()

function showTitle() {
    console.log(title.value)
}

// 子组件的方法
function someMethod() {
  console.log('子组件的方法被调用了')
}

// 子组件的数据
const someData = '这是子组件的数据'

// 导出子组件的方法和数据
defineExpose({
  someMethod,
  someData
})
</script>

<style scoped lang="scss">
.demo {
    background-color: green;
    margin: 10px 0;
    padding: 20px;
}
</style>

### 详细解析

#### 子组件 (Demo.vue)

1. 模板部分：
- <h1 ref="title">Demo组件</h1>：在子组件中，我们为 <h1> 标签添加了 ref 属性，并将其值设置为 "title"。这个 ref 属性会在子组件中创建一个引用，使得我们可以在子组件中通过 title 来访问这个 <h1> 元素。

2. 脚本部分：
- const title = ref()：我们创建了一个名为 title 的引用。这个 title 引用将与模板中 ref="title" 的 <h1> 元素关联起来。
- function someMethod() { console.log('子组件的方法被调用了') }：我们定义了一个子组件的方法 someMethod。
- const someData = '这是子组件的数据'：我们定义了一个子组件的数据 someData。
- defineExpose({ someMethod, someData })：我们使用 defineExpose 导出子组件的方法和数据，使得父组件可以通过 ref 访问到这些内容。

#### 父组件 (App.vue)

1. 模板部分：
- <Demo ref="demo" />：在父组件中，我们为子组件 <Demo> 添加了 ref 属性，并将其值设置为 "demo"。这个 ref 属性会在父组件中创建一个引用，使得我们可以在父组件中通过 demo 来访问子组件的实例。

2. 脚本部分：
- const demo = ref()：我们创建了一个名为 demo 的引用。这个 demo 引用将与模板中 ref="demo" 的子组件实例关联起来。
- function showDemo() { console.log(demo.value); demo.value.someMethod(); console.log(demo.value.someData) }：在 showDemo 方法中，我们通过 demo.value 访问到子组件的实例，并调用子组件的 someMethod 方法，访问子组件的 someData 数据。

### 总结

在 Vue 中，虽然你可以通过 ref 属性获取子组件的实例，但为了确保组件的封装性和安全性，子组件需要通过 defineExpose 显式地暴露其属性和方法。这样，父组件才能通过 ref 访问到这些暴露的内容。通过合理使用 defineExpose，你可以更好地控制组件之间的通信，同时保持组件的独立性和封装性。
02:46
在 Vue 中，使用局部样式（Scoped Styles）是一种常见的做法，它可以帮助你确保组件的样式仅作用于该组件内部的元素，而不会影响到其他组件或全局样式。局部样式通过在 <style> 标签上添加 scoped 属性来实现。这样父组件也不会应用到子组件的样式
03:20

在Vue项目或其他基于Webpack、Vite等构建工具的项目中，@ 通常是一个路径别名，代表项目的根目录。这是为了简化和方便引用文件路径，而不需要使用相对路径（比如 ../../types 这种形式）。

具体含义：
@ 表示项目的根目录（也就是 src 目录）。当你在代码中使用 @ 时，构建工具会自动将其解析为根目录的路径。
@/types 就相当于 src/types，也就是说它引用的是 src 目录下的 types 文件夹。
03:23
在 Vue 中，props 是一种用于父组件向子组件传递数据的机制。通过 props，父组件可以将数据传递给子组件，子组件则可以通过定义 props 来接收这些数据。props 是单向数据流的一部分，确保数据只能从父组件流向子组件，从而保持组件的独立性和可维护性。
03:37
要使用子组件就要在根组件里面注册，而使用setup之后，导入就相当于注册
03:48
vue3里面模板要绑定script里面的变量就要使用v-bind简写为
:
03:50
绑定script里面的变量有v-bind和ref
03:52

v-bind可以看做js表达式，它可以计算
04:08

在 Vue 中，props 是一种用于父组件向子组件传递数据的机制。通过 props，父组件可以将数据传递给子组件，子组件则可以通过定义 props 来接收这些数据。props 是单向数据流的一部分，确保数据只能从父组件流向子组件，从而保持组件的独立性和可维护性。



在父组件的script定义一个数据，然后传入子组件，也就是在子组件挂载父组件的元素里面，然后子组件在script里面使用defineProps接受，然后在模块里面使用
04:27

在 Vue 中，v-if 是一个条件渲染指令，用于根据表达式的真假值来决定是否渲染某个元素或组件。如果表达式的值为 true，则元素或组件会被渲染到 DOM 中；如果表达式的值为 false，则元素或组件不会被渲染，甚至不会存在于 DOM 中。

### 基本用法

<template>
  <div class="root">
    <h1 v-if="isVisible">Hello, Vue!</h1>
    <button @click="toggleVisibility">Toggle Visibility</button>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

// 数据
const isVisible = ref(true)

// 方法
function toggleVisibility() {
  isVisible.value = !isVisible.value
}
</script>

<style scoped lang="scss">
.root {
  padding: 20px;
}
</style>

### 详细解析

#### 模板部分

1. **<h1 v-if="isVisible">Hello, Vue!</h1>**：
- 这里我们使用 v-if 指令来根据 isVisible 的值决定是否渲染 <h1> 元素。如果 isVisible 为 true，则 <h1> 元素会被渲染到 DOM 中；如果 isVisible 为 false，则 <h1> 元素不会被渲染。

2. **<button @click="toggleVisibility">Toggle Visibility</button>**：
- 这个按钮绑定了一个点击事件，当按钮被点击时，会调用 toggleVisibility 方法。

#### 脚数据. **数据**：
- const isVisible = ref(true)：我们创建了一个名为 isVisible 的响应式数据，并将其初始值设置为 true。

2. **方法**：
- function toggleVisibility() { isVisible.value = !isVisible.value }：这个方法用于切换 isVisible 的值。当按钮被点击时，isVisible 的值会在 true 和 false 之间切换。
04:52

什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装，类似于vue2.x中的mixin。

自定义hook的优势：复用代码, 让setup中的逻辑更清楚易懂。
05:47

app.mount('#app')
这行代码用于将 Vue 应用挂载到指定的 DOM 元素上。
06:15

安装路由器:
npm i vue-router

创建一个个路由器，定义工作模式，导入路由组件，路由器里面定义一个个路由规则，那个路径是那个路由组件，路径就是url最后的，最后暴露出去给其他代码使用。
import {createRouter,createWebHistory} from 'vue-router'
import Home from '@/pages/Home.vue'
import News from '@/pages/News.vue'
import About from '@/pages/About.vue'

const router = createRouter({
history:createWebHistory(),
routes:[
{
path:'/home',
component:Home
},
{
path:'/about',
component:About
}
]
})
export default router

创建一个router文件夹，然后创建一个index.ts文件。

路由器下面是一个个路由，路由就是路径，内容就是components组件。


在main.ts哪里把路由器添加到vue应用里面，app.use(router)。
也就是main.ts添加这两行就行:
import router from './router/index'
app.use(router)



然后去App.vue里面修改，在script里面添加这个:
import {RouterLink,RouterView} from 'vue-router'
在模板里面添加这个元素，<RouterView></RouterView>，导航元素改为这个:

<div class="navigate">
<RouterLink to="/home" active-class="active">首页</RouterLink>
<RouterLink to="/news" active-class="active">新闻</RouterLink>
<RouterLink to="/about" active-class="active">关于</RouterLink>
</div>



创建了router文件夹和修改了main.ts文件，然后去App.vue里面修改。
06:27
路由组件通常存放在pages 或 views文件夹，一般组件通常存放在components文件夹。
06:54

嵌套路由:
编写子路由，去router文件夹里面index.ts配置路由规则，使用children配置项，去父路由哪里添加跳转，并预留一个<router-view>
07:16

query传参必须要使用to的第二种写法对象写法，
14:57


14:58
备注1：传递params参数时，若使用to的对象写法，必须使用name配置项，不能用path。

备注2：传递params参数时，需要提前在规则中占位。(就是router文件里面的index.ts里面的path)
14:59

15:18

问号是可选
16:06

### Vue 3 路由 props 配置的完整示例（包括 Detail 组件）

我们将分别使用对象写法、布尔值写法和函数写法，并展示如何在 Detail 组件中接收和使用这些传递的 props。

#### 1. 对象写法 (Object Mode)

// router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import Detail from './components/Detail.vue'

const routes = [
  {
    name: 'xiang',
    path: '/detail/:id/:title/:content',
    component: Detail,
    props: { a: 1, b: 2, c: 3 } // 传递静态 props
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

export default router

```vue
<!-- components/Detail.vue -->
<template>
<div>
<h1>对象写法</h1>
<p>a: {{ a }}</p>
<p>b: {{ b }}</p>
<p>c: {{ c }}</p>
</div>
</template>

<script lang="ts" setup>
defineProps({
a: Number,
b: Number,
c: Number
})
</script>

**解释：**
- 当你访问 `/detail/1/hello/world` 时，`Detail` 组件将会展示：
  

a: 1
b: 2
c: 3


---

#### 2. **布尔值写法 (Boolean Mode)**

ts
// router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import Detail from './components/Detail.vue'

const routes = [
{
name: 'xiang',
path: '/detail/:id/:title/:content',
component: Detail,
props: true // 自动传递路由 params 作为 props
}
]

const router = createRouter({
history: createWebHistory(),
routes
})

export default router


vue
<!-- components/Detail.vue -->
<template>
<div>
<h1>布尔值写法</h1>
<p>ID: {{ id }}</p>
<p>Title: {{ title }}</p>
<p>Content: {{ content }}</p>
</div>
</template>

<script lang="ts" setup>
defineProps({
id: String,
title: String,
content: String
})
</s解释：

**解释：**
- 当你访问 `/detail/1/hello/world` 时，`Detail` 组件将会展示：
  

ID: 1
Title: hello
Content: world


---

#### 3. **函数写法 (Function Mode)**

ts
// router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import Detail from './components/Detail.vue'

const routes = [
{
name: 'xiang',
path: '/detail/:id/:title/:content',
component: Detail,
props(route) {
return route.query // 传递 query 参数作为 props
}
}
]

const router = createRouter({
history: createWebHistory(),
routes
})

export default router


vue
<!-- components/Detail.vue -->
<template>
<div>
<h1>函数写法</h1>
<p>foo: {{ foo }}</p>
<p>baz: {{ baz }}</p>
</div>
</template>

<script lang="ts" setup>
defineProps({
foo: String,
baz: String
})解释：pt>

**解释：**
- 当你访问 `/detail/1/hello/world?foo=bar&baz=qux` 时，`Detail` 组件将会展示：
  

foo: bar
baz: qux
`

---

### 总结

通过不同的 `props` 写法，你可以灵活地控制数据如何从路由对象写法
1. **对象写法**：传递布尔值写法2. **布尔值写法**：直接将路由参数 (`params`) 作为 `pr函数写法
3. **函数写法**：根据路由对象自定义传递的 `props`，通常用于处理查询参数 (`query`)。

这样可以让你在不同的场景下使用最合适的方式进行数据传递。
16:14
query参数是在to哪里的
18:12

路由默认是push
18:28

replace: 不会添加新条目，而是替换当前的历史记录条目

路由可以替换为这个
18:34
如何使用replace属性，直接在导航元素哪里加就行

<RouterLink replace :to="{name: 'xinwen'}" active-class="active">新闻</RouterLink>


用户点击那个按钮，才链接css
20:50

Routelink跳转导航区呈现的是a标签
21:40

编程式路由导航，就是脱离Routelink实现路由跳转，使用在script处，希望达到某个条件就跳转

<script setup lang="ts" name="Home">
import { onMounted } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()

onMounted(() => {
setTimeout(() => {
router.push('/news')
}, 3000)
})
</script>
22:10

<script lang="ts" setup>
import { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from 'vue'

onBeforeMount(() => {
console.log('组件挂载之前');
})

onMounted(() => {
console.log('组件已挂载');
})

onBeforeUpdate(() => {
console.log('组件更新之前');
})

onUpdated(() => {
console.log('组件已更新');
})

onBeforeUnmount(() => {
console.log('组件卸载之前');
})

onUnmounted(() => {
console.log('组件已卸载');
})
</script>




vue3的生命周期钩子，就是说明这个vue组件的处于什么状态，你可以等待组件到达这个状态后写自己想要达到的想法
22:15
vue3重定向，直接在router/index.ts里面写入这个就行:
  {
    path: '/old-page',
    redirect: '/about' // 重定向到 /about
  },
27 September 2024
00:25

连续解构
00:56

当你将一个 ref 嵌套在 reactive 对象中时，Vue 会自动解包这个 ref，使得你可以直接访问它的值，而不需要使用 .value。
00:58
这里说的解包是对象里面的对象里面的值，而不是获取第一个对象的值，因为第一个对象的值是对象
01:38

Store是一个保存：状态、业务逻辑 的实体，每个组件都可以读取、写入它。

它有三个概念：state、getter、action，相当于组件中的： data、 computed 和 methods。
28 September 2024
23:37

pinia要保存数据，先在src文件夹里面创建store文件夹
29 September 2024
00:39

store里面的ts文件命名应该体现这个文件是干什么的
01:15

在 Vue 3 中，使用 Composition API 时，hook 的命名通常遵循以下约定：

1. **以 use 开头**：所有自定义 hook 都应以 use 开头，以明确其功能。

- 示例：useFetch, useCounter, useUser
描述性名称名称**：命名应清晰地描述该 hook 的功能，便于开发者理解。

- 示例：useLocalStorage, useDebounce, useApi
遵循驼峰命名法名法**：使用驼峰命名法（camelCase）来提高可读性。

这些命名约定有助于提高代码的可维护性和一致性，使得开发者能快速理解和使用这些 hook。


Composition API就是setup函数，


在 Vue 3 中，Composition API 是通过 setup 函数实现的。
01:22
const 是 JavaScript 中用于声明常量的关键字。使用 const 声明的变量在初始化后不能被重新赋值。这意味着你不能将一个新的值赋给已经用 const 声明的变量，但如果它是一个对象或数组，你仍然可以修改其内容。

### 示例：

const a = 10;  // a 的值为 10，不能再赋值
// a = 20;  // 这会报错

const obj = { name: 'Alice' };
obj.name = 'Bob';  // 这是允许的，因为 obj 的引用没有改变

const arr = [1, 2, 3];
arr.push(4);  // 这也是允许的

总结来说，`const` 用于创建一个不可重新赋值的变量，有助于提高代码的可读性和安全性。
01:47

import { defineStore } from 'pinia' 是从 Pinia 库中导入 defineStore 函数的语句。这个函数用于定义一个 store，它接受两个参数：一个唯一的 ID 和一个包含状态、动作和计算属性的对象。
01:50
在使用 defineStore 时，确保命名符合 Composition API hook 的命名规则，最后加上Store就行
02:06

读取RefImpl对象的值要使用.value读取，


当你将一个 ref 嵌套在 reactive 对象中时，Vue 会自动解包这个 ref，使得你可以直接访问它的值，而不需要使用 .value。


控制台显示:
Proxy 对象

说明是reactive对象，

显示:
RefImpl

说明是ref对象
02:09
之后定义的数据保存在store里面的每个部分的ts文件就行，组件直接读取store里面的ts文件里面的数据就行，不用再把数据保存在组件里面了
02:25

let：用于声明可变的变量，可以在后续代码中改变其值。
02:27
const 和 let 是 JavaScript 中用于声明变量的关键字，主要区别如下：

### 1. 可变性

- **const**：用于声明常量，一旦赋值后不能再更改。如果尝试重新赋值，会抛出错误。
- **let**：用于声明可变的变量，可以在后续代码中改变其值。
作用域 **作用域**

- 两者都具有块级作用域（block scope），这意味着它们的作用范围限于定义它们的代码块中。
提升（Hoisting）sting）**

- **const 和 let** 都会被提升，但在被声明之前无法使用（会抛出 ReferenceError），这与 var 不同。

### 示例：

// const 示例
const x = 10;
// x = 20; // 错误：不能重新赋值

// let 示例
let y = 5;
y = 15; // 合法，y 的值现在是 15

##const化**

- **const** 必须在声明时初始化，而 let 可以不初始化。

### 总结

使用 const 来定义常量，使用 let 来定义可能会变化的变量。希望这个解释能帮助你理解它们的区别！如果你还有其他问题，欢迎提问！
02:27
var 允许在同一作用域内重复声明同一变量，而 let 和 const 不允许，这可以通过以下示例体现：

### var 示例

var x = 10;
console.log(x); // 输出 10

var x = 20; // 允许重新声明
console.log(x); // 输出 20

在这个例子中，变量 `x 被重复声明，且不会报错。

### let 示例

``javascript
let y = 10;
console.log(y); // 输出 10

let y = 20; // 错误：不能重新声明

尝试重新声明 `y` 会导致语法错误。

### `const` 示例

javascript
const z = 30;
console.log(z); // 输出 30

const z = 40; // 错误：不能重新声明
`

同样，`const` 也不允许重新声明，会报错。

### 总结

- `var` 允许重复声明变量，后面的声明会覆盖前面的声明。
- `let` 和 `const` 不允许重复声明，同一作用域内重复声明会导致错误。

希望这个示例能帮助你更清楚地理解这一点！如果还有其他问题，请随时问我！
02:36
$patch 是 Pinia 中的一个方法，用于批量更新 store 的状态。它允许你一次性对多个状态属性进行更改，从而简化代码并提高性能。


countStore.$patch({
  sum:999,
  school:'atguigu'
})
02:42
$ 符号在 JavaScript 和框架中常常用于表示特定的功能、库或约定，帮助开发者识别和区分不同的上下文。
02:47
上下文中的 this
this 通常指向当前对象的实例，具体取决于如何调用函数。例如，在类的方法中，this 指向当前的类实例。
02:47
vue3淡化了this，但是ts没有
02:49
action里面放置的是一个个方法，之所以有时候用action是因为，有时候要用条件判断
02:50
直接修改是方便，$patch是可以批量修改，action是可以用于条件判断，也是为了复用，方便其他调用组件
03:01
StoreToRef只会关注store里面的数据，不会对其方法进行包裹，如果使用ToRef就会对其方法也进行包裹
03:09
计算属性： Getters 允许你定义基于 state 的计算属性，方便在组件中直接使用。
03:31

在 Pinia 中，$subscribe 是一个用于监听 store 状态变化的方法。它允许你在状态发生变化时执行一些特定的操作，非常适合用于持久化状态或其他需要响应状态变化的场景。


回调函数：$subscribe 接收一个回调函数，这个函数会在每次状态变化时被调用。回调函数有两个参数：
mutation：包含状态变化的信息，例如是哪个属性发生了变化。
state：当前的 store 状态(修改后的)。
11:21

在 Pinia 中，$subscribe 是一个用于监听 store 状态变化的方法。它允许你在状态发生变化时执行一些特定的操作，非常适合用于持久化状态或其他需要响应状态变化的场景。


回调函数：$subscribe 接收一个回调函数，这个函数会在每次状态变化时被调用。回调函数有两个参数：
mutation：包含状态变化的信息，例如是哪个属性发生了变化。
state：当前的 store 状态。
11:21
localStorage.getItem('talkList') 是用来从浏览器的本地存储中获取名为 'talkList' 的数据。如果这个键存在，getItem 会返回相应的字符串值；如果不存在，则返回 null。
12:36

store组合式写法是store写法的语法糖，或者说简写
12:42
语法糖（Syntactic Sugar）指的是一种让编程语言的语法更加简洁和易读的设计。它不改变语言的功能，只是提供了更直观或方便的写法，帮助开发者以更简洁的方式表达某些操作。
18:32

ref定义的数据在模板里面使用时，可以不使用.value
20:58

自定义事件名推荐使用kebab-case命名方式
30 September 2024
00:19

自定义事件是子传父，在模板里面定义一个事件，b事件绑定一个函数，再去script里面定义一个函数，



然后去子组件的script使用defineEmits声明事件，
const emit = defineEmits（[父组件定义事件]）

之后在子组件的任意位置调用emit（(父组件定义事件)，可选数据），就可以子传父了



绑定事件就是定义事件的意思。
01:15

mitt:
接收数据的：提前绑定好事件
提供数据的：在合适的时候触发事件（先导入emitter，然后在模板定一个触发按钮）


在src里面创建一个utils文件夹，然后创建一个emmiter.ts文件


然后这么写:

// 引入mitt
import mitt from 'mitt'

// 调用mitt得到emitter，emitter能：绑定事件，触发事件
const emitter = mitt()

// 暴露emitter
export default emitter




mitt库创建的emitter对象有以下常用的方法：

1. **on(type: string, handler: Function)**
绑定事件监听器，监听特定事件。
参数参数**：
- type: 事件的类型（名称）。
- handler: 当事件触发时要执行的处理函数。
示例示例**：

   emitter.on('event-name', (eventData) => {
     console.log(eventData)
   })
   

`off(type: string, handler: Function)n)**
移除事件监听器，停止监听特定事件。
- **参数**：
- type: 事件的类型（名称）。
- handler: 之前绑定的处理函数（必须是同一个函数引用）。
- **示例**：
``typescript
const handler = (eventData) => console.log(eventData)
emitter.on('event-name', handler)
emitter.off('event-name', handler)


3. **`emit(type: string, eventData?: any)`**  
   触发事件并传递数据给监听器。
   - **参数**：
     - `type`: 事件的类型（名称）。
     - `eventData`: 触发时传递的数据（可选）。
   - **示例**：
   

typescript
emitter.emit('event-name', {all.clear()

4. **`all.clear()`**  
   清除所有事件监听器。
   - **示例**：
   

typescript
emitter.all.clear()


#### 总结：
- on: 绑定事件监听器。
- off: 移除事件监听器。
- emit: 触发事件。
- all.clear`: 清除所有监听器。
01:17

01:36

emitter:子组件传子组件
08:19

: 是 v-bind 的简写形式，v-bind 用来绑定一个动态的属性。


为什么要有 :
静态属性：如果不加 :，就相当于直接将一个字符串 "a" 作为属性的值传递给子组件，而不是父组件中的变量。例如：<child a="a" /> 传递的 a 就是字面值字符串 "a"。
动态绑定：加上 :，表示这是一个动态绑定，Vue 会将父组件中 a 的实际值（此处为 ref(1) 的值）传递给子组件，而不是固定的字符串。
15:12

### Vue 3 中 $attrs 的使用：详细代码讲解

我们将创建一个简单的组件层级结构，其中父组件向孙组件传递属性。为了简化中间组件的处理，我们使用 $attrs 将属性从父组件传递到孙组件。接下来，我将详细解释每个组件的完整代码，适合小白用户理解。

### 1. 父组件 (Father.vue)

父组件是属性的起点，它向子组件传递多个属性，包括一些数字属性和一个更新数据的方法。

<template>
  <div class="father">
    <h3>父组件</h3>
    <!-- 向子组件传递了多个属性：a, b, c, d，以及通过 v-bind 绑定的对象 {x: 100, y: 200} -->
    <Child :a="a" :b="b" :c="c" :d="d" v-bind="{x:100, y:200}" :updateA="updateA" />
  </div>
</template>

<script lang="ts" setup>
import { ref } from 'vue'
import Child from './Child.vue'

// 定义父组件的数据
let a = ref(1)
let b = ref(2)
let c = ref(3)
let d = ref(4)

// 定义一个方法，用于更新 a 的值
function updateA(value) {
  a.value = value
}
</script>

<style scoped>
.father {
  border: 1px solid black;
  padding: 10px;
}
</style>

#### 解释：
- 属性传递：父组件定义了几个 ref 值 (a, b, c, d)，这些值会被传递给子组件。
- **v-bind 语法**：使用 v-bind 可以传递对象，这里传递了 {x: 100, y: 200}，作为属性 x 和 y 传递给子组件方法传递传递**：定义了一个更新 a 值的方法 updateA，同样通过属性的形式传递给子组件。

### 2. 子组件 (Child.vue)

子组件是中间层，它不会处理这些传递过来的属性，而是通过 $attrs 将它们直接传递给孙组件。

<template>
  <div class="child">
    <h3>子组件</h3>
    <!-- 使用 $attrs 传递所有非 props 的属性到孙组件 -->
    <GrandChild v-bind="$attrs" />
  </div>
</template>

<script lang="ts" setup>
import GrandChild from './GrandChild.vue'

// 子组件没有声明 props，它直接通过 $attrs 传递属性
</script>

<style scoped>
.child {
  border: 1px solid blue;
  padding: 10px;
}
</style>

#### 解释：
- **没有声明 props**：子组件没有显式声明任何 props，因此它不会消耗父组件传递的使用 $attrs$attrs**：子组件通过 $attrs 自动接收到父组件传递的未声明 props 的属性，然后使用 v-bind="$attrs" 将这些属性传递给孙组件。这些属性包括 x, y, 和 updateA。

### 3. 孙组件 (GrandChild.vue)

孙组件是属性的最终接收者，它接收并展示所有从父组件传递过来的属性，还能够使用传递的方法来更新父组件的数据。

<template>
  <div class="grand-child">
    <h3>孙组件</h3>
    <!-- 展示从父组件传递过来的属性 -->
    <h4>a：{{ a }}</h4>
    <h4>b：{{ b }}</h4>
    <h4>c：{{ c }}</h4>
    <h4>d：{{ d }}</h4>
    <h4>x：{{ x }}</h4>
    <h4>y：{{ y }}</h4>
    <!-- 点击按钮调用从父组件传递的 updateA 方法，更新 a 的值 -->
    <button @click="updateA(666)">点击我更新 A 的值</button>
  </div>
</template>

<script lang="ts" setup>
const props = defineProps(['a', 'b', 'c', 'd', 'x', 'y', 'updateA'])

// defineProps 用于明确孙组件接收的 props，这些是通过 $attrs 传递过来的
</script>

<style scoped>
.grand-child {
  border: 1px solid green;
  padding: 10px;
}
</style>

###接收 props props**：孙组件通过 defineProps 接收从父组件传递过来的所有属性：a, b, c, d, x, y，以及 updateA 方法。
- **展示属性**：组件使用模板语法 {{ }} 展示更新父组件数据 **更新父组件数据**：通过点击按钮，调用 updateA 方法，将 a 的值更新为 666。这个更新会反映到父组件，因为方法是从父组件传递下来的。父组件结

- **父组件** 定义了几个属性和一个方法子组件件。
- **子组件** 使用 $attrs 将未声明为 props 的属性自动传递给孙组件，而不需要在自己定义 props。
- **孙组件** 接收这些属性并展示，还可以调用传递的方法更新父组件的数据。

这整个结构演示了如何使用 $attrs 来简化属性传递，特别是在不需要中间层处理的情况下，从而让属性从父组件直接到达孙组件。

希望这个详细的代码和讲解对你有帮助！
15:12
$attrs
在script里面定义数据，传递给模板，
<template>
  <div class="father">
    <h3>父组件</h3>
    <!-- 向子组件传递了多个属性：a, b, c, d，以及通过 v-bind 绑定的对象 {x: 100, y: 200} -->
    <Child :a="a" :b="b" :c="c" :d="d" v-bind="{x:100, y:200}" :updateA="updateA" />
  </div>
</template>

<script lang="ts" setup>
import { ref } from 'vue'
import Child from './Child.vue'

// 定义父组件的数据
let a = ref(1)
let b = ref(2)
let c = ref(3)
let d = ref(4)

// 定义一个方法，用于更新 a 的值
function updateA(value) {
  a.value = value
}
</script>

<style scoped>
.father {
  border: 1px solid black;
  padding: 10px;
}
</style>


子组件直接导入孙组件，然后在模板那边写v-bind="$attrs"


孙组件就是使用defineProps接受，然后传递给模板。
1 October 2024
01:53

* 用在普通`DOM`标签上，获取的是`DOM`节点。

* 用在组件标签上，获取的是组件实例对象。
15:04

defineExpose 的作用：暴露一些属性或方法，数据
16:08

要操作子组件的实例步骤，首先要导入子组件，然后要创建一个引用（reference）来存储 子 组件的实例，然后在在模板中使用子组件，然后使用ref将子组件的实例赋值给之前创建的引用
17:25

`$refs`值为对象，包含所有被`ref`属性标识的`DOM`元素或组件实例。
`$refs`用于 ：**父→子。**

DOM 元素： 如果你在模板中的某个 HTML 元素（比如 <div>、<input> 等）上使用了 ref，这个 DOM 元素会被 Vue 自动记录，并存储在 $refs 对象中。这样你可以在代码中通过 $refs 来直接访问并操作该 DOM 元素。
<div ref="myDiv">Hello</div>



组件实例： 如果你在模板中使用了自定义组件，并为该组件添加了 ref，那么 $refs 中对应的值会是这个组件的实例。你可以通过组件实例调用该组件内定义的方法，或者访问组件的内部数据。
<template>
<child-component ref="myChildComponent"></child-component>
</template>



要求子组件使用defineExpose暴露属性或者方法，然后在就可以在父组件操作了，可以在 script里面定义一个函数，然后绑定点击事件，之后就可以通过按钮点击


`$parent`值为对象，当前组件的父组件实例对象。

父组件暴露属性和方法就行，可以在 script里面定义一个函数，然后绑定点击事件，之后就可以通过按钮点击
17:59

在 <template> 中使用 {{ money }} 而不是 {{ money.value }} 的原因是，Vue 的模板语法对 ref 做了自动解包（unwrapping）。也就是说，当你在模板中引用 ref 类型的变量时，Vue 会自动地去获取它的 .value 属性，因此你可以直接使用 money，就像它是一个普通的变量一样。
19:56

provide、inject：


父组件导入provide，然后再写这个就行`provide(注入名, 默认值)`

孙组件导入inject，然后再写这个就行


provide(注入名, 默认值)

provide() 函数的第一个参数是注入名（通常是字符串键），第二个参数是提供给子组件的值。


inject() 函数的使用方法

语法：const value = inject(注入名, 默认值)
只需要在子组件的 setup() 函数中调用 inject()，并传入与 provide() 时一致的键名，就能获取到对应的数据。
2 October 2024
02:09

slot的作用把组件标签之间的标签插入，子组件里面取，slot写在你想插入子组件标签的地方。




具名插槽，就是子组件里面的，slot标签有name属性，父组件里面的组件标签里面写入模板标签并有v-slot:子组件的name属性的值




作用域插槽: 子组件里面的slot标签，动态绑定数据，然后在父组件里面的组件标签里面写入模板标签并有v-slot=“params”，之后获取params里面的数据子组件绑定的数据就行，之后你就可以操作数据了。
3 October 2024
01:15

视图指的就是 template 部分的 HTML 结构，数据通常指的是 script 中定义的变量、状态或响应式数据。



双向绑定：通过 v-model 实现，视图和数据之间双向更新。数据和用户输入都会相互影响。
动态绑定：通过 v-bind 实现，仅从数据模型更新到视图，没有反向数据流（视图上的改变不会更新到数据模型）。
01:58

v-model在html标签:

在script定义数据，然后在模板哪里使用v-model绑定就行


v-model在组件标签:

在父组件上组件标签使用v-model绑定父组件里面的script里面的数据，子组件里面使用defineProps接受数据，defineEmits更新数据，然后在子组件的模板里面写这个：
  <input 
    type="text" 
    :value=接收的数据
    @input="emit('update:mima',(<HTMLInputElement>$event.target).value)"
  >
02:28

从 Vue 3.4 开始，推荐的实现方式是使用 defineModel() 宏而不是v-model

在父组件上组件标签使用v-model绑定父组件里面的script里面的数据，子组件在script里面使用defineModel() 接收数据，然后在子组件的模板使用v-model使用就行，

父组件：
v-model:first-name="first"


v-model:first-name: 这表示你正在使用 v-model 指令，并且你希望将 first-name 属性与 first 变量进行双向绑定。(first-name自定义的，不需要在script里面提前声明)
first: 这是父组件中的一个数据属性，在父组件的script里面声明的


子组件：
script接收：
const firstName = defineModel('firstName')

template模板使用：
<input type="text" v-model="firstName" />






在 Vue 3.4 中，defineModel() 是对组件内 v-model 机制的高级抽象，自动处理了 props 和 emit 的逻辑。因此，当你使用 defineModel() 宏时，不再需要手动监听 @input 并通过 emit 来更新父组件的数据，这就是为什么你的子组件中不需要显式地写出 @input 和 emit。



父组件：
<script setup>
import { ref } from 'vue'
import UserName from './UserName.vue'

const first = ref('John')
const last = ref('Doe')
</script>

<template>
  <h1>{{ first }} {{ last }}</h1>
  <UserName
    v-model:first-name="first"
    v-model:last-name="last"
  />
</template>



子组件：
<script setup>
const firstName = defineModel('firstName')
const lastName = defineModel('lastName')
</script>

<template>
  <input type="text" v-model="firstName" />
  <input type="text" v-model="lastName" />
</template>



官方案例：
https://play.vuejs.org/#eNqFkstuwjAQRX/F8iZUAqKKHQpIfbAoUmnVx86bKEzANLEt26FUkf+9Y4MDSAg2UWbu9fjckVv6oNRw2wAd08wUmitLDNhGTZngtZLakpZoKIkjpZY1SdCadNK3Ab3IazhowzQ2/ES0MVFIYSwpucbvxA/qJXO5FsldlKr8qDxL8EKW7kEQAQsLtapyC1gRkq3vp217mOccwf8wwLksRSlYIoMvCNkOarmEahyODAT2J4yGgtFzhx8UDf5/r6c4NEs7CNqnpxkvbO0kcVjNhCyh5AJe/SW9pBPOV3DJGvu3dsKFaiyxf8qTW9gheQwVs4Z90BDm5oF47cF/Ht4aZC75argxUmD61g9ktJC14hXoN2U5ZmJ0TILitbyq5O889KxuoB/7xRqKnwv9jdn5HqPvGnDVWwTpNJvrFSCul2efi4DeiRigqdB9RfwAI6vGM+5tj41YIvaJL9C+hOfNxerLzHYWhImhPKh3uuBnFJ/A05XoR9zRcBTOMeGo+wcs+yse
02:39
props是指组件属性
02:44
在 HTML 中，placeholder 是一个属性，用于在输入框（如 <input> 或 <textarea>）中显示占位符文本。占位符文本通常用于提示用户输入框中应该填写什么类型的信息。