---
title: 委托
icon: code
order: 9
category:
  - C#学习
tag:
  - C#
  - 委托
---

# 委托

在C#中，委托（Delegate）是一种引用类型，它允许你将方法作为参数传递、存储在变量中。委托本质上是对方法的引用，它`定义了`方法的签名（`参数列表和返回类型`），并可以指向任何具有相同签名的方法。

委托里面的`=`，委托的调用列表将被重置；委托里面的`+=`，向委托的调用列表添加方法；委托里面的`-=`，向委托的调用列表移除特定的方法。

## 委托的定义

委托的声明使用`delegate`关键字，后跟返回类型、委托名称和参数列表。例如：

```csharp
public delegate void MyDelegate(int number);
```

这个委托可以指向任何返回类型为`void`且接受一个`int`参数的方法。

## 委托的实例化

要使用委托，首先需要创建一个委托实例，并将一个具有匹配签名的方法赋值给它。方法可以是静态的、实例的，甚至可以是匿名方法或lambda表达式。例如：

```csharp
public void PrintNumber(int number)
{
    Console.WriteLine(number);
}

MyDelegate myDelegate = new MyDelegate(PrintNumber);
```

## 委托的调用

一旦委托实例被创建并指向某个方法，就可以像调用方法一样调用委托实例。创建之后，传递给委托的参数将被传递给委托指向的方法。例如：

```csharp
myDelegate(10); // 调用PrintNumber方法并传入10
```


### 完整的例子

```csharp
public delegate void MyDelegate(int number);

public void PrintNumber(int number)
{
    Console.WriteLine(number);
}

// 显式使用 new
MyDelegate myDelegate = new MyDelegate(PrintNumber);

myDelegate(10); // 调用PrintNumber方法并传入10
```

或者更加简洁的写法


```csharp
public delegate void MyDelegate(int number);

public void PrintNumber(int number)
{
    Console.WriteLine(number);
}

// 现在的委托和注册事件都不需要new，直接赋值即可
MyDelegate myDelegate = PrintNumber;

myDelegate(10); // 调用PrintNumber方法并传入10
```


### 委托的调用方式

在C#中，委托的调用有两种方式：

1. 直接调用委托变量（如 `myDelegate(10)`）
2. 使用 `Invoke()` 方法（如 `myDelegate.Invoke(10)`）

无论是直接调用还是使用 `Invoke()`，最终都会调用委托的 `Invoke` 方法。直接调用只是语法糖，编译后都会变成 `Invoke` 调用。



## 预定义委托

Action 和 Func 都是 .NET 框架中预定义的泛型委托关键字(相当于声明好的委托模板，使用时只需要直接传入匹配的方法)。它们都可以用于表示无返回值和有返回值的方法。

在 C# 中， T 是一个泛型类型参数的常用名称（"T" 代表 "Type"）。它是一个占位符，可以在使用类、方法、接口或委托时被具体的类型替换。

### Func 使用示例

```csharp
public static T Execute<T>(Func<AppDbContext, T> func)
// - 第一个 T 表示方法的返回类型
// - <T> 声明了一个泛型类型参数
{
    using (var context = CreateContext())
    {
        return func(context);
    }
}

var allData = DatabaseService.Execute(context => context.WpfTests.ToList());
```

## 事件（Event）与委托（Delegate）的区别

### 核心区别

事件是对委托的封装，只允许 `+=` 和 `-=` 操作，禁止直接赋值（`=`）和调用（`Invoke`）。

### 事件比委托多了一层封装

#### 委托的本质

委托（Delegate）是一个**方法指针列表**，可以存储多个方法。
外部代码可以**直接修改**这个列表（赋值、调用、清空）。

#### 事件的本质

事件（Event）在**委托的基础上**增加了一层**访问控制**：
- **外部只能 `+=` 订阅和 `-=` 取消订阅**，不能直接修改委托。
- **只能在声明事件的类内部触发**（如 `OnClick()` 方法）。

### 事件示例

```csharp
public class Button
{
    // 1. 声明事件
    public event EventHandler Click;
    
    // 触发事件的方法
    public void OnClick()
    {
        Click?.Invoke(this, EventArgs.Empty);
    }
}

public class Program
{
    public static void Main()
    {
        Button btn = new Button();
        
        // 2. 注册事件处理程序
        btn.Click += Button_Click;
        
        // 触发事件
        btn.OnClick();
    }
    
    // 3. 事件处理方法
    private static void Button_Click(object sender, EventArgs e)
    {
        Console.WriteLine("按钮被点击了！");
    }
}
```


### 使用场景

- **自定义委托**：一般用于多播委托，实现观察者模式。
- **预定义委托**：一般作为参数声明，用于回调函数或事件处理。
- **事件**：用于实现发布-订阅模式，提供更安全的委托封装，常用于UI编程和组件通信。